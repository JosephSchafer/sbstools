#!/usr/bin/python
# calculate velocity between GPS-coordinates
# to check integrity of GPS data sent by aircrafts 
# Copyright (GPL) 2007 Dominik Bartenstein <db@wahuu.at>
import MySQLdb
import logging
from logging import handlers
import ogr, osr
import sys, os
import math
from ConfigParser import SafeConfigParser

logging.basicConfig(level=logging.INFO, format='%(asctime)s %(levelname)s %(message)s')
verbose = 0
MAXSPEED1 = 1500
MAXSPEED2 = 2500
MAXSPEED3 = 5000
LOGFILE = "gpsaccuracy.log"

def setupLogging():
    ''' set up the Python logging facility '''

    # define a Handler which writes INFO messages or higher to a file which is rotated when it reaches 5MB
    handler = handlers.RotatingFileHandler(LOGFILE, maxBytes = 5 * 1024 * 1024, backupCount=7)
    # set a nice format
    formatter = logging.Formatter('%(asctime)s %(levelname)s %(message)s')
    # tell the handler to use this format
    handler.setFormatter(formatter)
    # add the handler to the root logger
    logger = logging.getLogger('')
    logger.setLevel(logging.INFO)
    logging.getLogger('').addHandler(handler)
    
class DistanceCalc:
    # based on code from by Aapo Rista (http://positio.rista.net/en/pys60gps/)
    # http://mathforum.org/library/drmath/view/55417.html
    # tc1=mod(atan2(sin(lon2-lon1)*cos(lat2),
    #         cos(lat1)*sin(lat2)-sin(lat1)*cos(lat2)*cos(lon2-lon1)),
    #         2*pi)
    def rad2deg(self, rad):
        """Convert radians to degrees.
        Return float radians."""
        return rad * 180 / math.pi
    
    def deg2rad(self, deg):
        """Convert degrees to radians.
        Return float degrees"""
        return deg * math.pi / 180

    def distance(self, lat1, lon1, lat2, lon2):
        """Calculate dinstance between two lat/lon pairs.
        Return float distance in meters."""
        lat1 = self.deg2rad(lat1)
        lon1 = self.deg2rad(lon1)
        lat2 = self.deg2rad(lat2)
        lon2 = self.deg2rad(lon2)
        theta = lon1 - lon2
        dist = math.sin(lat1) * math.sin(lat2) \
             + math.cos(lat1) * math.cos(lat2) * math.cos(theta)
        if dist >= 1:
            dist = 1
        dist = math.acos(dist)
        dist = self.rad2deg(dist)
        meters = dist * 60 * 1852
        return meters

class VelocityChecker:
    ''' calculate velocity for sections  '''
    
    def __init__(self, host, db, user, password):
        self.db = MySQLdb.connect(host = host, db = db, user = user, passwd = password)
      
    def checkAllFlights(self):
        ''' check all flights '''
        
        cursor = self.db.cursor()
        sql = "SELECT id FROM flights WHERE mergestate IS NOT NULL AND gpsaccuracy IS NULL AND ts > '2007-04-01 00:00'"
        cursor.execute(sql)
        rs = cursor.fetchall()
        for record in rs:
            id = record[0]
            gpsaccuracy = self.checkFlight(id)
            self.markFlight(id, gpsaccuracy)
        cursor.close()
    
    def markFlight(self, flightid, gpsaccuracy):
        ''' set gpsaccuracy for flight '''
        
        cursor = self.db.cursor()
        sql = "UPDATE flights SET gpsaccuracy=%i WHERE id=%i" % (gpsaccuracy, flightid)
        logging.info(sql)
        cursor.execute(sql)
        self.db.commit()
        cursor.close()
    
    def checkFlight(self, flightid):
        ''' check GPS data of flight '''
        
        spatref = osr.SpatialReference()
        spatref.SetWellKnownGeogCS("WGS84")
        distcalc = DistanceCalc()
        
        logging.info("checking flight #%i" %flightid)
        points = []
        cursor = self.db.cursor()
        sql = "SELECT latitude, longitude, UNIX_TIMESTAMP(time)*1000 + time_ms AS timestamp_ms FROM flightdata WHERE flightid=%i" %flightid
        # __DO NOT__ ORDER BY timestamp_ms ASC" as the timestamp info seems to be generated by the basestation and does not reflect reception time  
        cursor.execute(sql)
        rs = cursor.fetchall()
        # add all relevant flightdata to list!
        for record in rs:
            x = record[0]
            y = record[1]
            timestamp_ms = long(record[2])
            # ignore all (0, 0)-infos 
            if x != 0 and y != 0:
                points.append( (x, y, timestamp_ms) )
        cursor.close()    
    
        # distance between very first and last point
        totaldistance = 0.0
        # distance between first point and last point of partial line
        stepdistance = 0
        c = 0 
        t = 0  
 
        velocities = []
        pnt = None
        THRESHOLD = 5*1000   #5 kilometres 
        for x, y, ms in points:
            try:
                starttime
                if stepdistance == 0:
                    starttime = endtime 
            except:
                starttime = ms
            endtime = ms
 
            pnt2 = ogr.Geometry(ogr.wkbPoint)
            pnt2.AssignSpatialReference(spatref)
            pnt2.SetPoint_2D(0, x, y)
            if pnt == None:
                pnt = pnt2
            if stepdistance == 0:
                startpnt = pnt
            # calculate distance between point1 and point2
            distance = distcalc.distance( pnt.GetX(), pnt.GetY(), pnt2.GetX(), pnt2.GetY() )
            totaldistance += distance
            stepdistance += distance
            
            # make sure that velocity is also calculated if the threshold cannot be reached
            # due to end of list
            # __FIXME__: last section could consist of only 2 points and therefore lead to inaccurate gps accuracy info
            if stepdistance > THRESHOLD or points.index( (x, y, ms) ) == len(points) - 1:
            	timediff = endtime - starttime
            	try:
                    velocity = (3600.0 * 1000 / timediff) * stepdistance / 1000.0
                except:
                	velocity = -1
                # gotta convert distance into a readable format, e.g. km
                if distance > 0:
                    if verbose:
                        logging.info( "%f km between (%f, %f) and (%f, %f)" %(stepdistance/1000, startpnt.GetX(), startpnt.GetY(), pnt2.GetX(), pnt2.GetY()) )
                        logging.info("\t%d %d" %(starttime, endtime) )
                        logging.info( "\t%d ms between these = %f kmph" % (timediff, velocity))
                    velocities.append( velocity )
                c += stepdistance
                t += timediff
                stepdistance = 0
            # pnt2 becomes pnt1 for the next round
            pnt = pnt2
        
        # calculate timediff between very first and very last point
        if len(points) < 2 or not len(velocities):
            return -1
        timediff = points[-1][2] - points[0][2]
        # sort velocitys of partial lines
        velocities.sort()
        try:
            avgvelocity = (3600.0 * 1000 / timediff) * totaldistance / 1000.0
        except ZeroDivisionError:
            return -1
        if velocities[-1] > MAXSPEED1 or avgvelocity > MAXSPEED1:
            logging.info("\taverage velocity: %f kmph (distance: %f, timediff: %f)" % (avgvelocity, totaldistance, timediff))
            logging.info("\tmaximum partial velocity: %f kmph" % velocities[-1])
            logging.info("\tsection distance: %f km" % c)
            logging.info("\ttime diff: %f ms" % t)
        
        # LIMIT1
        vcheck = velocities[-1] > 0 and velocities[-1] < MAXSPEED1 
        avgcheck = avgvelocity > 0 and avgvelocity < MAXSPEED1
        if vcheck and avgcheck:
            return 10
        if vcheck or avgcheck:
            return 9
        
        # LIMIT2
        vcheck = velocities[-1] > 0 and velocities[-1] < MAXSPEED2 
        avgcheck = avgvelocity > 0 and avgvelocity < MAXSPEED2
        if vcheck and avgcheck:
            return 8
        if vcheck or avgcheck:
            return 7
       
       # LIMIT3
        vcheck = velocities[-1] > 0 and velocities[-1] < MAXSPEED3 
        avgcheck = avgvelocity > 0 and avgvelocity < MAXSPEED3
        if vcheck and avgcheck:
            return 6
        if vcheck or avgcheck:
            return 5
        
        return 1
       
def main():
    ''' distance checker '''
    
    logging.info("### gpsaccuracy checker started")
    logging.info("reading configuration ...")
    cfg = SafeConfigParser()
    cfg.read(sys.path[0] + os.sep + '../sbstools.cfg')
    dbhost = cfg.get('db', 'host')
    dbname = cfg.get('db', 'database')
    dbuser = cfg.get('db', 'user')
    dbpassword = cfg.get('db', 'password') 
    
    velocitychecker = VelocityChecker(dbhost, dbname, dbuser, dbpassword)
    velocitychecker.checkAllFlights()
    logging.info("### gpsaccuracy checker finished")
 
if __name__ == '__main__':
    setupLogging()
    main()
